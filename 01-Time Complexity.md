
# 시간 복잡도(Time Complexity)

- 시간 복잡도 : 주어진 문제를 해결하기 위한 연산 횟수
- 수행 시간은 일반적으로 1억 번의 연산 = 1초로 간주한다.

<br>

## 시간 복잡도 정의하기
- 빅 오메가(Ω(n)) : 최선일 때의 연산 횟수를 나타낸 표기법
- 빅 세타(θ(n)) : 보통일 때의 연산 횟수를 나타낸 표기법
- 빅 오(O(n)) : 최악일 때의 연산 횟수를 나타낸 표기법

<br>

간단하게 설명하자면 만약 배열에 1~5까지의 숫자가 저장되어있고 어떤 숫자를 찾는다고 해보자.<br>
[1, 2, 3, 4, 5] <br>
빅 오메가일 경우 Ω(1), 빅 세타일 경우 θ(2/N), 빅 오일 경우 N번이 된다. 즉 `빅 오메가`일 경우 어떤 숫자는 '1'이 되어 배열에 있는 숫자를 한 번(시간 복잡도 1)에 찾을 수 있게 되고, `빅 세타`일 경우 어떤 숫자가 2, 3, 4가 되는 경우일텐데 대충 평균 적인 횟수를 구한다고 쳐서 시간 복잡도는 2/N이 된다. 그리고 제일 최악일 때의 표기법인 `빅 오`일 경우 맨 어떤 숫자가 맨 마지막(5)에 있는 경우를 말해 복잡도는 N이 된다.
<br> <br> <br>


### 코딩 테스트에서의 시간 복잡도 유형?
코딩 테스트에서는 `빅-오 표기법(O(n))`을 기준으로 수행 시간을 계산하면 된다. 일반적으로 코딩 테스트에서는 하나의 테스트 케이스가 아닌 여러 개의 테스트 케이스를 통과해야 합격되기 때문에 여러가지 다양한 경우의 수를 생각하여 문제를 풀어야하기 때문에 항상 **최악일 때를 염두**해 두어야 한다.

<br> <br> <br>


## 시간 복잡도 활용
### 알고리즘 선택의 기준으로 사용
- 버블 정렬(O(n<sup>2</sup>)), 병합 정렬(O(nlogn))을 알고있다고 가정하자.

<br>

N개의 수가 주어졌을 때 이를 오름차순으로 정렬하는 프로그램을 작성하는 문제가 나왔다. 단, 시간 제한은 2초라고 가정하면 총 2억 번 이하의 연산 횟수로 문제를 해결해야 한다.

<br>


#### **연산 횟수 계산 방법**

```
연산 횟수 = 알고리즘 시간 복잡도 * 데이터의 크기
```

위 문제에서 데이터의 크기는 최대 1,000,000개라고 할 때 다음과 같이 계산된다.
- 버블 정렬 = (1,000,000)<sup>2</sup> = 1,000,000,000,000 > 200,000,000 → 부적합
- 병합 정렬 = 1,000,000log(1,000,000) = 약 20,000,000 < 200,000,000 → 적합

<br>
<br>
<br>

## 시간 복잡도를 바탕으로 코드 로직 개선하기
시간 복잡도로 작성한 코드의 비효율적인 로직을 개선하는 바탕으로 사용할 수 있다. 그러려면 가장 먼저 코드의 시간 복잡도를 도출할 수 있어야 한다.

<br>

#### **시간 복잡도 도출 기준**
1. 상수는 시간 복잡도 계산에서 제외
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

<br> <br>

